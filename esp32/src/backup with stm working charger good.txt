#include <Adafruit_NeoPixel.h>
#include <Arduino.h>
#include <WiFi.h>
#include <Wire.h>
#include <esp_wifi.h>
#include <math.h>

#include "../lib/INA226/INA226.h"

// -------------------- I¬≤C Mutex --------------------
SemaphoreHandle_t i2c_mutex = NULL;

// -------------------- Pin Definitions --------------------
#define FET_CHARGE 5
#define FET_WELD 4   // SAFETY: held LOW, ESP32 no longer welds
#define PEDAL_PIN 6  // UNUSED now (pedal moves to STM32)
#define I2C_SDA 2
#define I2C_SCL 3
#define THERM_PIN 7
#define LED_PIN 21
#define BUTTON_PIN 1

// -------------------- STM32 UART bridge pins -------------
#define STM32_TO_ESP32_PIN 11  // ESP32 RX  <- STM32 TX (PA9)
#define ESP32_TO_STM32_PIN 12  // ESP32 TX  -> STM32 RX (PA10)
HardwareSerial STM32Serial(2);

// -------------------- WiFi / TCP Settings ----------------
const char* ssid = "Jaime's Wi-Fi Network";
const char* password = "jackaustin";

WiFiServer server(8888);
WiFiClient client;

// -------------------- INA226 (cell voltage only) ---------
INA226 ina(0x40);       // Pack voltage
INA226 inaCell1(0x41);  // Node 1
INA226 inaCell2(0x44);  // Node 2

// -------------------- LED & Button -----------------------
Adafruit_NeoPixel led(1, LED_PIN, NEO_RGB + NEO_KHZ800);
bool system_enabled = true;
volatile bool welding_now = false;  // driven by STM32 events

// -------------------- Battery monitoring -----------------
float vpack = 0.0;
float current_charge = 0.0;
unsigned long last_battery_read = 0;
const unsigned long BATTERY_READ_INTERVAL = 100;

const float V_NODE1_SCALE = 1.290;
const float V_NODE2_SCALE = 1.490;
const float VPACK_SCALE = 1.000;

// -------------------- Battery thresholds -----------------
const float CHARGE_LIMIT = 9.16;
const float CHARGE_RESUME = 8.70;
const float HARD_LIMIT = 9.2;

// -------------------- Weld settings (forwarded to STM32) --
uint8_t weld_mode = 1;  // 1=single, 2=double, 3=triple
uint16_t weld_d1 = 10;
uint16_t weld_gap1 = 0;
uint16_t weld_d2 = 0;
uint16_t weld_gap2 = 0;
uint16_t weld_d3 = 0;
uint8_t weld_power_pct = 100;  // 50-100%
bool preheat_enabled = false;
uint16_t preheat_ms = 20;
uint8_t preheat_pct = 30;
uint16_t preheat_gap_ms = 3;

uint16_t weld_duration_ms = 10;  // legacy: still shown in STATUS
unsigned long last_weld_time = 0;
const unsigned long WELD_COOLDOWN = 500;

// -------------------- Thermistor -------------------------
float temperature_c = NAN;
float temp_ema = NAN;
float temp_last_valid = NAN;

const float SERIES_RESISTOR = 10000.0f;
const float THERMISTOR_NOMINAL = 10000.0f;
const float TEMPERATURE_NOMINAL = 25.0f;
const float BETA_COEFF = 3950.0f;
const float TEMP_EMA_ALPHA = 0.05f;
const float TEMP_OUTLIER_THRESH = 5.0f;

// Calibration offset in ¬∞C (matches Fluke at ambient)
float TEMP_OFFSET_C = -2.2f;

// -------------------- Forward declarations ---------------
void updateBattery();
void updateTemperature();
void controlCharger();
void processCommand(String cmd);
String buildStatus();
void sendToPi(const String& msg);
void forwardToStm32(const String& line);
void pollStm32Uart();
void updateLED();
void handleButton();

// -------------------- Cell reading helpers ---------------
bool readCellsOnce(float& V1, float& V2, float& V3, float& C1, float& C2,
                   float& C3) {
    if (xSemaphoreTake(i2c_mutex, pdMS_TO_TICKS(100)) != pdTRUE) {
        return false;
    }

    // Read node1 bus voltage register (0x02) directly for raw mV conversion
    Wire.beginTransmission(0x41);
    Wire.write(0x02);
    Wire.endTransmission(false);
    Wire.requestFrom((uint8_t)0x41, (uint8_t)2);
    if (Wire.available() < 2) {
        xSemaphoreGive(i2c_mutex);
        return false;
    }
    uint16_t raw1 = (Wire.read() << 8) | Wire.read();
    float v_node1_raw = raw1 * 0.00125f;

    // Read node2 bus voltage register (0x02)
    Wire.beginTransmission(0x44);
    Wire.write(0x02);
    Wire.endTransmission(false);
    Wire.requestFrom((uint8_t)0x44, (uint8_t)2);
    if (Wire.available() < 2) {
        xSemaphoreGive(i2c_mutex);
        return false;
    }
    uint16_t raw2 = (Wire.read() << 8) | Wire.read();
    float v_node2_raw = raw2 * 0.00125f;

    xSemaphoreGive(i2c_mutex);

    float v_node1 = v_node1_raw * V_NODE1_SCALE;
    float v_node2 = v_node2_raw * V_NODE2_SCALE;
    float v_pack = vpack;

    V1 = v_node1;
    V2 = v_node2;
    V3 = v_pack;

    C1 = v_node1;
    C2 = v_node2 - v_node1;
    C3 = v_pack - v_node2;

    return true;
}

// -------------------- Thermistor helpers -----------------
float readThermistorOnce() {
    int raw = analogRead(THERM_PIN);
    if (raw <= 0) raw = 1;
    if (raw >= 4095) raw = 4094;

    float v = 3.3f * ((float)raw / 4095.0f);
    float r_therm = SERIES_RESISTOR * (v / (3.3f - v));

    float steinhart = r_therm / THERMISTOR_NOMINAL;
    steinhart = logf(steinhart);
    steinhart /= BETA_COEFF;
    steinhart += 1.0f / (TEMPERATURE_NOMINAL + 273.15f);
    steinhart = 1.0f / steinhart;
    steinhart -= 273.15f;

    return steinhart;
}

void updateTemperature() {
    float t_raw = readThermistorOnce();
    if (!isfinite(t_raw)) return;

    t_raw += TEMP_OFFSET_C;

    if (!isfinite(temp_last_valid)) {
        temp_last_valid = t_raw;
        temp_ema = t_raw;
        temperature_c = t_raw;
        return;
    }

    float diff = fabsf(t_raw - temp_last_valid);
    if (diff > TEMP_OUTLIER_THRESH) return;

    temp_last_valid = t_raw;

    if (!isfinite(temp_ema)) {
        temp_ema = t_raw;
    } else {
        temp_ema = TEMP_EMA_ALPHA * t_raw + (1.0f - TEMP_EMA_ALPHA) * temp_ema;
    }

    temperature_c = temp_ema;
}

// -------------------- Helper: Build STATUS line ----------
String buildStatus() {
    bool charge_on = digitalRead(FET_CHARGE);
    String state = charge_on ? "ON" : "OFF";

    String t_str;
    if (isfinite(temperature_c)) {
        t_str = String(temperature_c, 1);
    } else {
        t_str = "NaN";
    }

    unsigned long now = millis();
    long cooldown_ms = (long)(WELD_COOLDOWN - (now - last_weld_time));
    if (cooldown_ms < 0) cooldown_ms = 0;

    float display_current =
        (fabs(current_charge) < 0.2f) ? 0.0f : current_charge;

    String status = "STATUS";
    status += ",enabled=" + String(system_enabled ? 1 : 0);
    status += ",state=" + state;
    status += ",vpack=" + String(vpack, 3);
    status += ",i=" + String(display_current, 3);
    status += ",temp=" + t_str;
    status += ",cooldown_ms=" + String(cooldown_ms);
    status += ",pulse_ms=" + String(weld_duration_ms);
    status += ",power_pct=" + String(weld_power_pct);
    status += ",preheat_en=" + String(preheat_enabled ? 1 : 0);
    status += ",preheat_ms=" + String(preheat_ms);
    status += ",preheat_pct=" + String(preheat_pct);
    status += ",preheat_gap_ms=" + String(preheat_gap_ms);
    status += ",mode=" + String(weld_mode);
    status += ",d1=" + String(weld_d1);
    status += ",gap1=" + String(weld_gap1);
    status += ",d2=" + String(weld_d2);
    status += ",gap2=" + String(weld_gap2);
    status += ",d3=" + String(weld_d3);

    return status;
}

// -------------------- Helper: Send line to Pi ------------
void sendToPi(const String& msg) {
    if (client && client.connected()) {
        client.println(msg);
        Serial.printf("[TCP] TX: %s\n", msg.c_str());
    } else {
        Serial.printf("[TCP] Not connected, drop: %s\n", msg.c_str());
    }
}

// -------------------- UART forward helper ----------------
void forwardToStm32(const String& line) {
    STM32Serial.println(line);
    Serial.printf("[UART->STM32] %s\n", line.c_str());
}

// -------------------- STM32 UART RX -> Pi relay ----------
void pollStm32Uart() {
    static String stmLine;

    while (STM32Serial.available()) {
        char ch = (char)STM32Serial.read();
        if (ch == '\r') continue;

        if (ch == '\n') {
            stmLine.trim();
            if (stmLine.length() > 0) {
                Serial.printf("[STM32->UART] %s\n", stmLine.c_str());

                if (stmLine.startsWith("EVENT,WELD_START")) {
                    welding_now = true;
                } else if (stmLine.startsWith("EVENT,WELD_DONE")) {
                    welding_now = false;
                    last_weld_time = millis();
                }

                sendToPi(stmLine);
            }
            stmLine = "";
        } else {
            if (stmLine.length() < 220) stmLine += ch;
        }
    }
}

// -------------------- Battery / Charger ------------------
void updateBattery() {
    if (xSemaphoreTake(i2c_mutex, pdMS_TO_TICKS(100)) == pdTRUE) {
        float raw_vpack = ina.readBusVoltage();
        vpack = raw_vpack * VPACK_SCALE;

        // Shunt voltage reg (0x01): 2.5uV/bit (signed)
        Wire.beginTransmission(0x40);
        Wire.write(0x01);
        Wire.endTransmission(false);
        Wire.requestFrom((uint8_t)0x40, (uint8_t)2);

        if (Wire.available() >= 2) {
            int16_t raw_shunt = (Wire.read() << 8) | Wire.read();
            float shunt_voltage_v = raw_shunt * 0.0000025f;

            // NOTE: your shunt is assumed 0.2 mŒ© here:
            // I = V / R
            float calculated_current = shunt_voltage_v / 0.0002f;
            current_charge = -calculated_current;
        }

        xSemaphoreGive(i2c_mutex);
    }
}

void controlCharger() {
    if (!system_enabled || welding_now) {
        digitalWrite(FET_CHARGE, LOW);
        return;
    }

    static int high_count = 0;

    if (vpack >= HARD_LIMIT) {
        high_count++;
    } else {
        high_count = 0;
    }

    if (high_count >= 2) {
        digitalWrite(FET_CHARGE, LOW);
        Serial.printf("‚ö†Ô∏è HARD LIMIT - Charging OFF (vpack=%.2fV)\n", vpack);
        return;
    }

    if (vpack >= CHARGE_LIMIT) {
        digitalWrite(FET_CHARGE, LOW);
    } else if (vpack < CHARGE_RESUME) {
        digitalWrite(FET_CHARGE, HIGH);
    }
}

// -------------------- Command Parser ---------------------
void processCommand(String cmd) {
    Serial.printf("[CMD] Processing: %s\n", cmd.c_str());

    if (cmd.startsWith("SET_PULSE,")) {
        int idx = 10;
        int commaPos;

        commaPos = cmd.indexOf(',', idx);
        if (commaPos > 0) {
            weld_mode = cmd.substring(idx, commaPos).toInt();
            idx = commaPos + 1;
        }

        commaPos = cmd.indexOf(',', idx);
        if (commaPos > 0) {
            weld_d1 = cmd.substring(idx, commaPos).toInt();
            idx = commaPos + 1;
        }

        commaPos = cmd.indexOf(',', idx);
        if (commaPos > 0) {
            weld_gap1 = cmd.substring(idx, commaPos).toInt();
            idx = commaPos + 1;
        }

        commaPos = cmd.indexOf(',', idx);
        if (commaPos > 0) {
            weld_d2 = cmd.substring(idx, commaPos).toInt();
            idx = commaPos + 1;
        }

        commaPos = cmd.indexOf(',', idx);
        if (commaPos > 0) {
            weld_gap2 = cmd.substring(idx, commaPos).toInt();
            idx = commaPos + 1;
        }

        weld_d3 = cmd.substring(idx).toInt();
        weld_duration_ms = weld_d1;

        Serial.printf("‚úÖ Pulse: mode=%d d1=%d gap1=%d d2=%d gap2=%d d3=%d\n",
                      weld_mode, weld_d1, weld_gap1, weld_d2, weld_gap2,
                      weld_d3);

        forwardToStm32(cmd);
        sendToPi("ACK:SET_PULSE," + String(weld_mode));
        return;
    }

    if (cmd.startsWith("SET_POWER,")) {
        weld_power_pct = cmd.substring(10).toInt();
        if (weld_power_pct < 50) weld_power_pct = 50;
        if (weld_power_pct > 100) weld_power_pct = 100;

        Serial.printf("‚úÖ Weld power set to %d%%\n", weld_power_pct);

        forwardToStm32(cmd);
        sendToPi("ACK:SET_POWER," + String(weld_power_pct));
        return;
    }

    if (cmd.startsWith("SET_PREHEAT,")) {
        int idx = 12;
        int commaPos;

        commaPos = cmd.indexOf(',', idx);
        if (commaPos > 0) {
            preheat_enabled = (cmd.substring(idx, commaPos).toInt() == 1);
            idx = commaPos + 1;
        }

        commaPos = cmd.indexOf(',', idx);
        if (commaPos > 0) {
            preheat_ms = cmd.substring(idx, commaPos).toInt();
            idx = commaPos + 1;
        }

        commaPos = cmd.indexOf(',', idx);
        if (commaPos > 0) {
            preheat_pct = cmd.substring(idx, commaPos).toInt();
            idx = commaPos + 1;
        } else {
            preheat_pct = cmd.substring(idx).toInt();
            Serial.printf("‚úÖ Preheat: %s, %dms, %d%% (gap unchanged=%dms)\n",
                          preheat_enabled ? "ON" : "OFF", preheat_ms,
                          preheat_pct, preheat_gap_ms);

            forwardToStm32(cmd);
            sendToPi("ACK:SET_PREHEAT," + String(preheat_enabled ? 1 : 0));
            return;
        }

        preheat_gap_ms = cmd.substring(idx).toInt();

        Serial.printf("‚úÖ Preheat: %s, %dms, %d%%, gap=%dms\n",
                      preheat_enabled ? "ON" : "OFF", preheat_ms, preheat_pct,
                      preheat_gap_ms);

        forwardToStm32(cmd);
        sendToPi("ACK:SET_PREHEAT," + String(preheat_enabled ? 1 : 0));
        return;
    }

    if (cmd.startsWith("ARM,")) {
        forwardToStm32(cmd);
        sendToPi("ACK:ARM_FWD");
        return;
    }

    if (cmd == "FIRE") {
        Serial.println("‚ö†Ô∏è FIRE ignored (STM32 pedal-only mode)");
        sendToPi("ACK:FIRE_IGNORED");
        return;
    }

    if (cmd == "CHARGE_ON") {
        digitalWrite(FET_CHARGE, HIGH);
        Serial.println("‚úÖ Charging ON (manual)");
        sendToPi("ACK:CHARGE_ON");
        return;
    }

    if (cmd == "CHARGE_OFF") {
        digitalWrite(FET_CHARGE, LOW);
        Serial.println("‚úÖ Charging OFF (manual)");
        sendToPi("ACK:CHARGE_OFF");
        return;
    }

    if (cmd == "STATUS") {
        sendToPi(buildStatus());
        forwardToStm32("STATUS");
        return;
    }

    // Unknown: ignore
}

// -------------------- LED update -------------------------
void updateLED() {
    if (!system_enabled) {
        led.setPixelColor(0, led.Color(255, 0, 0));
    } else if (welding_now) {
        led.setPixelColor(0, led.Color(255, 255, 255));
    } else if (digitalRead(FET_CHARGE)) {
        led.setPixelColor(0, led.Color(0, 0, 255));
    } else {
        led.setPixelColor(0, led.Color(0, 255, 0));
    }
    led.show();
}

// -------------------- Button handler ---------------------
void handleButton() {
    static unsigned long press_start = 0;
    static unsigned long last_release = 0;
    static bool was_pressed = false;
    static bool waiting_for_double = false;
    static unsigned long double_tap_window = 0;

    bool is_pressed = (digitalRead(BUTTON_PIN) == LOW);

    if (is_pressed && !was_pressed) {
        press_start = millis();
    } else if (!is_pressed && was_pressed) {
        unsigned long press_duration = millis() - press_start;
        unsigned long time_since_last = millis() - last_release;

        if (press_duration >= 2000) {
            Serial.println("üîò Long press ‚Üí entering deep sleep");
            waiting_for_double = false;
            esp_deep_sleep_start();
        } else if (press_duration >= 50) {
            if (waiting_for_double && time_since_last <= 500) {
                Serial.println("üîò Double tap ‚Üí RESETTING ESP32...");
                delay(100);
                ESP.restart();
            } else {
                waiting_for_double = true;
                double_tap_window = millis();
            }
        }

        last_release = millis();
    }

    if (waiting_for_double && (millis() - double_tap_window > 500)) {
        system_enabled = !system_enabled;
        Serial.printf("üîò Single tap ‚Üí system %s\n",
                      system_enabled ? "ENABLED" : "DISABLED");

        if (!system_enabled) {
            digitalWrite(FET_CHARGE, LOW);
            forwardToStm32("ARM,0");  // disarm when disabled
        } else {
            forwardToStm32("ARM,1");  // re-arm when enabled
        }

        waiting_for_double = false;
    }

    was_pressed = is_pressed;
}
void ensureWiFiAndServer() {
    static unsigned long last_attempt = 0;
    static bool server_started = false;

    // If we are connected, ensure server is started
    if (WiFi.status() == WL_CONNECTED) {
        if (!server_started) {
            Serial.println("‚úÖ WiFi connected (re) - IP: " +
                           WiFi.localIP().toString());
            Serial.println("Starting TCP server on port 8888...");
            server.begin();
            server.setNoDelay(true);
            server_started = true;
        }
        return;
    }

    // Not connected: mark server not started, drop any client
    server_started = false;
    if (client) {
        client.stop();
    }

    // Retry WiFi every 5 seconds
    unsigned long now = millis();
    if (now - last_attempt > 5000) {
        last_attempt = now;
        Serial.println("‚ö†Ô∏è WiFi disconnected; retrying...");
        WiFi.reconnect();  // or WiFi.begin(ssid, password) if you prefer
    }
}

// -------------------- Setup ------------------------------
void setup() {
    Serial.begin(115200);
    delay(500);

    // UART to STM32
    STM32Serial.begin(115200, SERIAL_8N1, STM32_TO_ESP32_PIN,
                      ESP32_TO_STM32_PIN);
    Serial.println("‚úÖ STM32 UART bridge ready (Serial2 @ 115200)");

    // Create I¬≤C mutex
    i2c_mutex = xSemaphoreCreateMutex();
    if (i2c_mutex == NULL) {
        Serial.println("‚ùå Failed to create I¬≤C mutex!");
    } else {
        Serial.println("‚úÖ I¬≤C mutex created");
    }

    Serial.println(
        "\n=== ESP32 Weld Controller - GATEWAY MODE (STM32 weld) ===");

    // Pins
    pinMode(FET_WELD, OUTPUT);
    digitalWrite(FET_WELD, LOW);  // ALWAYS LOW on ESP32

    pinMode(PEDAL_PIN, INPUT_PULLUP);  // not used anymore
    pinMode(THERM_PIN, INPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(LED_PIN, OUTPUT);

    led.begin();
    led.setBrightness(50);
    led.setPixelColor(0, led.Color(255, 255, 0));
    led.show();

    analogReadResolution(12);

    // I¬≤C
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(50000);
    Wire.setTimeOut(1000);

    // Quick scan of expected INAs
    Serial.println("\n=== I¬≤C Device Check (expected 0x40, 0x41, 0x44) ===");
    uint8_t addrs[] = {0x40, 0x41, 0x44};
    for (uint8_t addr : addrs) {
        Wire.beginTransmission(addr);
        uint8_t err = Wire.endTransmission();
        Serial.printf("I2C addr 0x%02X -> %s\n", addr,
                      (err == 0) ? "OK" : "NO ACK");
        delay(10);
    }

    if (xSemaphoreTake(i2c_mutex, portMAX_DELAY) == pdTRUE) {
        if (ina.begin(&Wire)) {
            Serial.println("‚úÖ INA226 (pack) initialized");

            // Configure pack INA (0x40)
            Wire.beginTransmission(0x40);
            Wire.write(0x00);
            Wire.write(0x45);
            Wire.write(0x27);
            Wire.endTransmission();
            delay(10);

            uint16_t cal_value = 41967;
            Wire.beginTransmission(0x40);
            Wire.write(0x05);
            Wire.write((cal_value >> 8) & 0xFF);
            Wire.write(cal_value & 0xFF);
            Wire.endTransmission();
            delay(10);

            if (inaCell1.begin(&Wire)) {
                Serial.println("‚úÖ INA226 cell1 (0x41) initialized");
            } else {
                Serial.println("‚ö†Ô∏è INA226 cell1 (0x41) init failed");
            }

            if (inaCell2.begin(&Wire)) {
                Serial.println("‚úÖ INA226 cell2 (0x44) initialized");
            } else {
                Serial.println("‚ö†Ô∏è INA226 cell2 (0x44) init failed");
            }

            updateBattery();
            updateTemperature();
            Serial.printf("   Initial Vpack: %.2fV\n", vpack);
            Serial.printf("   Initial Current: %.2fA\n", current_charge);
            if (isfinite(temperature_c))
                Serial.printf("   Initial Temp: %.1fC\n", temperature_c);

            controlCharger();
        } else {
            Serial.println("‚ö†Ô∏è INA226 init failed - charging disabled");
        }
        xSemaphoreGive(i2c_mutex);
    } else {
        Serial.println("‚ùå Failed to acquire I¬≤C mutex in setup!");
    }

    // WiFi
    WiFi.mode(WIFI_STA);
    esp_wifi_set_protocol(
        WIFI_IF_STA, WIFI_PROTOCOL_11B | WIFI_PROTOCOL_11G | WIFI_PROTOCOL_11N);

    Serial.print("Connecting to: ");
    Serial.println(ssid);

    WiFi.begin(ssid, password);
    //  WiFi.setTxPower(WIFI_POWER_8_5dBm);

    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 40) {
        delay(500);
        Serial.print(".");
        attempts++;
        if (attempts % 10 == 0) {
            Serial.print(" [");
            Serial.print((int)WiFi.status());
            Serial.print("] ");
        }
    }

    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\n‚úÖ WiFi CONNECTED!");
        Serial.print("IP: ");
        Serial.println(WiFi.localIP());

        Serial.println("Starting TCP server on port 8888...");
        server.begin();
        server.setNoDelay(true);
    } else {
        Serial.println("\n‚ùå WiFi FAILED!");
    }

    // Charger FET
    pinMode(FET_CHARGE, OUTPUT);
    digitalWrite(FET_CHARGE, LOW);
    Serial.println("‚úÖ FET_CHARGE initialized (GPIO 5 set LOW)");

    Serial.println("\n=== GATEWAY READY (STM32 does weld timing) ===");

    // Push current settings to STM32 once at boot
    forwardToStm32("SET_PULSE," + String(weld_mode) + "," + String(weld_d1) +
                   "," + String(weld_gap1) + "," + String(weld_d2) + "," +
                   String(weld_gap2) + "," + String(weld_d3));
    forwardToStm32("SET_POWER," + String(weld_power_pct));
    forwardToStm32("SET_PREHEAT," + String(preheat_enabled ? 1 : 0) + "," +
                   String(preheat_ms) + "," + String(preheat_pct) + "," +
                   String(preheat_gap_ms));
}

// -------------------- Loop -------------------------------
void loop() {
    ensureWiFiAndServer();
    pollStm32Uart();

    // TCP accept/read
    if (WiFi.status() == WL_CONNECTED) {
        if (!client || !client.connected()) {
            if (client) {
                client.stop();
                Serial.println("[TCP] Old connection closed");
            }

            WiFiClient newClient = server.available();
            if (newClient) {
                client = newClient;
                client.setNoDelay(true);
                Serial.println("[TCP] Client connected from " +
                               client.remoteIP().toString());

                // Send immediate status snapshots
                sendToPi(buildStatus());
                forwardToStm32("STATUS");
            }
        } else if (client.available()) {
            String line = client.readStringUntil('\n');
            line.trim();
            if (line.length() > 0) {
                Serial.printf("[TCP] RX: %s\n", line.c_str());
                processCommand(line);
            }
        }
    }

    // periodic monitoring
    if (millis() - last_battery_read >= BATTERY_READ_INTERVAL) {
        last_battery_read = millis();
        updateBattery();
        updateTemperature();
        controlCharger();

        static unsigned long last_print = 0;
        if (millis() - last_print >= 2000) {
            last_print = millis();

            bool should_charge =
                (vpack < CHARGE_RESUME && vpack < CHARGE_LIMIT);
            bool charging_active =
                should_charge && !welding_now && system_enabled;

            Serial.printf("üìä Vpack=%.2fV I=%.2fA %s", vpack, current_charge,
                          charging_active ? "‚ö°CHARGING" : "‚è∏Ô∏èIDLE");
            if (isfinite(temperature_c)) {
                Serial.printf("  Temp=%.1fC\n", temperature_c);
            } else {
                Serial.println();
            }

            sendToPi(buildStatus());

            float V1, V2, V3, C1, C2, C3;
            if (readCellsOnce(V1, V2, V3, C1, C2, C3)) {
                char buf[160];
                snprintf(
                    buf, sizeof(buf),
                    "CELLS,V1=%.3f,V2=%.3f,V3=%.3f,C1=%.3f,C2=%.3f,C3=%.3f", V1,
                    V2, V3, C1, C2, C3);
                sendToPi(String(buf));
            }
        }
    }

    handleButton();
    updateLED();

    delay(10);
}